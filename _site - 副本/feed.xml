<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Adventure in Coding</title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 16 Apr 2015 20:50:49 +0800</pubDate>
    <lastBuildDate>Thu, 16 Apr 2015 20:50:49 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &amp;#39;Hi, Tom&amp;#39; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://github.com/jekyll/jekyll-help&quot;&gt;Jekyll’s dedicated Help repository&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Fri, 17 Apr 2015 00:44:43 +0800</pubDate>
        <link>/jekyll/update/2015/04/17/welcome-to-jekyll</link>
        <guid isPermaLink="true">/jekyll/update/2015/04/17/welcome-to-jekyll</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>Linux-ZigBee项目：在Linux上运行6lowpan（一）</title>
        <description>&lt;p&gt;前段时间在看ZigBee的物理层和MAC层协议栈，也就是IEEE802.15.4协议。之后，发现sourceforge上有一个&lt;a href=&quot;http://sourceforge.net/projects/linux-zigbee/&quot;&gt;linux-zigbee&lt;/a&gt;的项目，&lt;a href=&quot;http://blog.chinaunix.net/uid-29653824-id-4351049.html&quot;&gt;中文翻译介绍&lt;/a&gt;。虽然这个项目叫Linux-ZigBee，但是因为许可问题除了IEEE802.15.4协议，其它的都没有实现，转而转向6lowpan，所以本文介绍一下用Ubuntu串口连接CC2530运行6lowpan。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;section&quot;&gt;交叉编译内核&lt;/h1&gt;

&lt;p&gt;由于主线内核只包含了&lt;code&gt;ieee802154&lt;/code&gt;、&lt;code&gt;fakehard&lt;/code&gt;和&lt;code&gt;6lowpan&lt;/code&gt;，所以没办法使用ZigBee串口设备。所以要下载linux-zigbee内核：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://git.code.sf.net/p/linux-zigbee/kernel -b 6lowpan linux-zigbee-kernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然也可以去项目主页下载。下载完成之后，进行源码目录，然后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择&lt;code&gt;mac802154&lt;/code&gt;、&lt;code&gt;ieee802154&lt;/code&gt;和&lt;code&gt;serial&lt;/code&gt;等模块。然后保存退出，进行编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -j 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果出现错误可以网上搜解决方法，编译完成之后，编译模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着安装模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make modules_install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装内核：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，内核已经编译并且安装成功了。重启PC之后，加载相关模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo modprobe ieee802154
sudo modprobe mac802154
sudo modprobe af_802154
sudo modprobe serial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每当需使用时，都必须加载上述模块。&lt;/p&gt;

&lt;h1 id=&quot;lowpan-tools&quot;&gt;安装lowpan-tools&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;lowpan-tools&lt;/code&gt;是管理Linux LowPAN协议栈的工具，由于Ubuntu的lowpan-tools版本太老了，所以需要从项目主页下载安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://git.code.sf.net/p/linux-zigbee/linux-zigbee linux-zigbee-linux-zigbee
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载完成之后，进入源码目录安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./autogen.sh
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成之后，便可以使用&lt;code&gt;izattach&lt;/code&gt;工具添加ZigBee串口设备。&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Oct 2014 00:00:00 +0800</pubDate>
        <link>/linux/2014/10/30/6lowpan_on_linux</link>
        <guid isPermaLink="true">/linux/2014/10/30/6lowpan_on_linux</guid>
        
        <category>linux</category>
        
        <category>embedded</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>交叉编译OpenWrt上的Helloworld</title>
        <description>&lt;p&gt;终于编译完成了OpenWrt，并且成功交叉编译了Helloworld，并在Easy-Link的板子上运行。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;openwrt-sdk&quot;&gt;编译OpenWrt SDK&lt;/h1&gt;

&lt;p&gt;编译OpenWrt的过程，可参考&lt;a href=&quot;/openwrt/2014/08/10/compile_openwrt&quot;&gt;OpenWrt的编译&lt;/a&gt;。编译配置我勾选了&lt;code&gt;Advanced configuration option&lt;/code&gt;、&lt;code&gt;Build the OpenWrt SDK&lt;/code&gt;和&lt;code&gt;Build the OpenWrt based Toolchain&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;编译完成之后，交叉编译工具链在类似&lt;code&gt;staging_dir/toolchain-architecture_gcc-compilerver_uClibc-libcver/bin/&lt;/code&gt;目录。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;配置环境变量&lt;/h1&gt;

&lt;p&gt;主要配置以下环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH=$PATH:(toolchain/bin目录)
export PATH

STAGING_DIR=(toolchain目录)
export STAGING_DIR
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;helloopenwrt&quot;&gt;交叉编译Helloopenwrt&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;helloopenwrt.c&lt;/code&gt;的源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;

int main() {
    printf(&quot;Hello OpenWrt\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进行交叉编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;architecture-openwrt-linux-uclibc-gcc helloopenwrt.c -o helloopenwrt.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将生成的&lt;code&gt;hellowopenwrt.o&lt;/code&gt;文件用scp上传到Easy-Link上，并用ssh登录到Easy-Link上，并运行，便可以看到终端输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello OpenWrt
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 11 Aug 2014 00:00:00 +0800</pubDate>
        <link>/openwrt/2014/08/11/helloworld_on_openwrt</link>
        <guid isPermaLink="true">/openwrt/2014/08/11/helloworld_on_openwrt</guid>
        
        <category>openwrt</category>
        
        <category>embedded</category>
        
        
        <category>openwrt</category>
        
      </item>
    
      <item>
        <title>OpenWrt编译过程中出现的错误</title>
        <description>&lt;p&gt;编译OpenWrt不是件容易的事情，编译过程中要下载包，并且会出现很多奇怪的错误，经过几个小时的编译，终于成功了。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;错误的捕获可以通过以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make V=99
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section&quot;&gt;下载错误&lt;/h1&gt;

&lt;p&gt;在编译的过程中，会从网上下载很多源码及包，由于服务器在国外，所以很不稳定，出现下载错误时，你可以多试几次，或者直接下载包放在相应目录。我的解决方法是用代理翻墙到国外下载。&lt;/p&gt;

&lt;h1 id=&quot;patch&quot;&gt;patch补丁文件错误&lt;/h1&gt;

&lt;p&gt;在编译过程中，可能会出现以下的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;malformed patch at line xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是由于应用patch 时都会检查受影响的行数是否与记录在两个 @@ 之间的数值一致，如果不一致的话，就要打开patch文件手动修改那个数值以符合受影响的行数。具体可以参考&lt;a href=&quot;http://blog.chinaunix.net/uid-11134731-id-33192.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;kconfig&quot;&gt;Kconfig错误&lt;/h1&gt;

&lt;p&gt;在编译时，可能某个Konfig文件出现以下的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;endif&#39; in different file than &#39;if&#39;
location of the &#39;if&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是Kconfig文件出现问题（&lt;a href=&quot;https://lkml.org/lkml/2010/9/27/533&quot;&gt;参考&lt;/a&gt;），只要打开相应的Kconfig文件，在他的最后一行加个加车就行了，我也不知道为什么。&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Aug 2014 00:00:00 +0800</pubDate>
        <link>/openwrt/2014/08/11/error_on_compiling_openwrt</link>
        <guid isPermaLink="true">/openwrt/2014/08/11/error_on_compiling_openwrt</guid>
        
        <category>openwrt</category>
        
        <category>embedded</category>
        
        
        <category>openwrt</category>
        
      </item>
    
      <item>
        <title>OpenWrt的编译</title>
        <description>&lt;p&gt;最近在淘宝上买了基于AR9331的Easy-Link模块，尝试着编译了一下OpenWrt，编译环境为ubuntu 12.04。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;section&quot;&gt;安装组件&lt;/h1&gt;

&lt;p&gt;打开终端，安装编译所需的组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install gcc g++ binutils patch bzip2 flex bison make autoconf gettext texinfo unzip sharutils subversion libncurses5-dev ncurses-term zlib1g-dev git-core gawk asciidoc libz-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;openwrt&quot;&gt;下载及更新Openwrt源码&lt;/h1&gt;

&lt;p&gt;打开终端，输入下以命令下载源码,当然还可以下载其它的版本，注意不要包含中文路径。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;svn co svn://svn.openwrt.org/openwrt/branches/attitude_adjustment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入源码目录，更新源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;svn update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新源：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./scripts/feeds update -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装下载好的包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./scripts/feeds install -a
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;编译配置&lt;/h1&gt;

&lt;p&gt;打开终端，输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开OpenWrt配置界面进行配置。当然，Easy-Link有自己的补丁包。&lt;/p&gt;

&lt;p&gt;如果你想配置内核，可以在终端中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make kernel_menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt;编译&lt;/h1&gt;

&lt;p&gt;在终端中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -j 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的2表示用2个线程进行编译，适用于多核CPU。在编译过程中会下载相应的文件，编译完成后，会在bin目录生成固件文件。&lt;/p&gt;

&lt;p&gt;如果想清除生成的文件，可在终端中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想初始化编译环境，可在终端中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make dirclean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想查看编译详细内容，或者捕获错误，可在终端中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make V=99
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 10 Aug 2014 00:00:00 +0800</pubDate>
        <link>/openwrt/2014/08/10/compile_openwrt</link>
        <guid isPermaLink="true">/openwrt/2014/08/10/compile_openwrt</guid>
        
        <category>openwrt</category>
        
        <category>embedded</category>
        
        
        <category>openwrt</category>
        
      </item>
    
      <item>
        <title>VoCore启动成功</title>
        <description>&lt;p&gt;换了个VoCore板之后，VoCore就能正常启动了，顺便测试了一下ssh和ap+sta模式。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;ssh&quot;&gt;SSH连接&lt;/h1&gt;

&lt;p&gt;VoCore连上电源后，等待大约30秒之后，便会有发出一个ssid为VoCore的无加密wifi。连上之后，在浏览器输入192.168.1.1，进入Openwrt的Luci界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/2014-08-06%2010:17:23%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用户名为root，密码为vocore，登录进去之后，系统会提示修改密码并开启ssh，按照提示操作之后，打开终端，输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh root@192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入密码之后，便可以登录进去了。&lt;/p&gt;

&lt;h1 id=&quot;staap&quot;&gt;STA+AP模式&lt;/h1&gt;

&lt;p&gt;根据作者博客介绍，VoCore的STA和AP能够同时工作。首先，开启STA模式，添加下面内容到｀/etc/config/network`。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config interface wwan
    option proto &#39;dhcp&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，修改&lt;code&gt;/etc/config/wireless&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config wifi-device  radio0
	option type     mac80211
	option channel  11
	option hwmode	11ng
	option path	&#39;10180000.wmac&#39;
	list ht_capab	GF
	list ht_capab	SHORT-GI-20
	list ht_capab	SHORT-GI-40
	list ht_capab	RX-STBC1
	option htmode	HT20

config wifi-iface
    option device   radio0
	option network  lan
	option mode     ap
	option ssid     VoCore
	option encryption none

config wifi-iface
	option device   radio0
	option network  wwan
	option mode     sta
    option ssid     VongerWifi
	option encryption psk2
	option key      PasswordForWifi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改相应ssid与密码即可。&lt;/p&gt;

&lt;p&gt;如果，你家的路由是用192.168.1.1作它的IP地址，那么为避免冲突，你必须修改VoCore的IP，修改文件里相应的IP，如192.168.61.1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config interface &#39;lan&#39;
	option ifname &#39;eth0.1&#39;
	option type &#39;bridge&#39;
	option proto &#39;static&#39;
	option ipaddr &#39;192.168.61.1&#39;
	option netmask &#39;255.255.255.0&#39;
	option ip6assign &#39;60&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启连接成功之后，VoCore便可以访问外网了。&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Aug 2014 00:00:00 +0800</pubDate>
        <link>/vocore/2014/08/06/first_start_of_vocore</link>
        <guid isPermaLink="true">/vocore/2014/08/06/first_start_of_vocore</guid>
        
        <category>vocore</category>
        
        <category>embedded</category>
        
        <category>wifi</category>
        
        
        <category>vocore</category>
        
      </item>
    
      <item>
        <title>为Jekyll增加不完美的分页和文章摘要</title>
        <description>&lt;p&gt;怎么说呢，用Jekyll搭建Blog不管被说的多么好用，但终究应该只属于技术宅+爱折腾的群体吧，经常一个Wordpress上的小功能，却要在Jekyll折腾不少时间，比如之前的站内搜索，以及今天的分页以及文章摘要，足足折腾了我一下午，而且最后的解决方案还是不完美，有点小挫败感。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;回到主题，下面先说下Jekyll分页，这个功能有内置的，但是非常见鬼的，只支持对index.html的分页，你没看错，文件名必须是这个，如果你是用JB的话，把index.md重命名成index.html，然后再继续往下看：&lt;/p&gt;

&lt;p&gt;修改_config.yml文件，增加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 每一页显示的文章数
paginate: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加了上面后，你就可以在index.html页面中，引用paginator这个对象了，记住，只有index.html页面可以用。&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td&gt;变量名&lt;/td&gt;	                &lt;td&gt;描述&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.per_page&lt;/td&gt;     &lt;td&gt;每页的文章数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.posts&lt;/td&gt;        &lt;td&gt;这个分页下所有的文章列表&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.total_posts&lt;/td&gt;  &lt;td&gt;总文章数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.total_pages&lt;/td&gt;  &lt;td&gt;总页数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.page&lt;/td&gt;         &lt;td&gt;当前页&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.previous_page&lt;/td&gt;&lt;td&gt;前一页&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.next_page&lt;/td&gt;    &lt;td&gt;后一页&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;具体如何使用，参考&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Pagination&quot;&gt;How pagination works&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;前面也提到了，这个只支持首页模式，也就是说，你的Blog里有多个文章类目，然后这个是不支持的，所以我称做为不完美的分页。不过我的Blog文章还少，而且我向来是个比较懒的人，等分类下的文章也多了，再来想怎么解决吧。&lt;/p&gt;

&lt;p&gt;下面说说怎么搞文章摘要，如果没有摘要的，列表展示是很头大的。目前有这么几种方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;用内置的truncate或者truncatewords方法，这个好处是内置的，不需要装插件，不需要装插件意味着你可以在托管Github上用，因为Github上很多插件都不支持。但缺点也很明显，对html的标签支持不是很好，如果你是纯文本的Blog，倒也还好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;装truncatehtml插件。这个插件首先需要nokogiri，所以你需要在本地安装，安装命令如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;gem install nokogiri
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;然后再安装上述的插件，这个插件的好处就是对解析后的html代码进行控制，但坏处就是，你如果是托管在Github上，那就悲剧了，不能用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面两种方法，都有一个问题，就是对所有文章的摘要提取都是一样的，但是有时候，对于不同的问题，我想显示不同长度的摘要，所以下面隆重祭出第三种方法（其实，也是我在网上找的，版权不归我哈）： 
首先，在你文章里，想要输出摘要的截至地方，打上标签，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ---
 title: some post
 layout: post
 ---

 我有一头小毛驴呀，从来也不骑。

 &amp;lt;!--break--&amp;gt;

 有一天我心血来潮骑它取赶集。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用下面的方式截取：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  \{\{ post.content  | | split:&#39;&amp;lt;!--break--&amp;gt;&#39; | first \}\}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的方式，就是，你需要在写文章的时候，打一个注释，但是，这个成本，我想，还好吧。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文转自：&lt;a href=&quot;http://kingauthur.info/2013/01/20/the-paginator-and-excerpt-in-jekyll/&quot;&gt;http://kingauthur.info/2013/01/20/the-paginator-and-excerpt-in-jekyll/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Aug 2014 00:00:00 +0800</pubDate>
        <link>/daily/2014/08/04/paginate_and_excerpt_on_jekyll</link>
        <guid isPermaLink="true">/daily/2014/08/04/paginate_and_excerpt_on_jekyll</guid>
        
        <category>jekyll</category>
        
        
        <category>daily</category>
        
      </item>
    
      <item>
        <title>VoCore首次启动失败</title>
        <description>&lt;p&gt;本来以为首次启动应该顺顺利利的，但是，问题总是在遇到我的时候变得很复杂，问题总是以意思不到的形式出现，接上电源后，竞然搜不到ssid为VoCore的WiFi。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;vocore&quot;&gt;VoCore的电源&lt;/h1&gt;

&lt;p&gt;如图所示，VoCore输入电源3.3V~6.0V，经MT3410L转换成3.3V，再经MT3410L转成1.8V，给RT5350F供电。因此，只要输入5.0V的USB电源便可以正常运行了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWDDZ6oi/medium.jpg&quot; alt=&quot;VoCore电源&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本人决定用Mini USB线来改装。Mini USB有4条线，分别是红、白、绿、蓝（黑），其中红是正极，蓝（黑）是地，将这两根线接到图中红框所示的地方，便可以正常启动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DXff2TTy/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWDDWsPw/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;问题出现&lt;/h1&gt;

&lt;p&gt;接上5V USB电源之后，LED亮了大约1秒，之后，大约隔18秒之后，led亮了大约15秒，之后，又等了好久，始终看不到VoCore的Wifi出现。询问作者Vonger，Vonger表示led正常，要求给出USB-TTL的Log进行分析，所以又制作了VoCore的USB-TTL。&lt;/p&gt;

&lt;h1 id=&quot;usb-ttl&quot;&gt;USB-TTL输出&lt;/h1&gt;

&lt;p&gt;依照Vonger博客上的方法，使用USB-TTL模块，并将相应引脚接到红框部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DXfetmAA/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWDDVduJ/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;电脑端的串口调试客户端，我用的是putty，相关的串口参数如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;波特率57600&lt;/li&gt;
  &lt;li&gt;数据位8位&lt;/li&gt;
  &lt;li&gt;无校验位&lt;/li&gt;
  &lt;li&gt;停止位1位&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之后，便可以打印出log信息。&lt;/p&gt;
</description>
        <pubDate>Thu, 31 Jul 2014 00:00:00 +0800</pubDate>
        <link>/vocore/2014/07/31/failed_on_first_start_of_vocore</link>
        <guid isPermaLink="true">/vocore/2014/07/31/failed_on_first_start_of_vocore</guid>
        
        <category>vocore</category>
        
        <category>embedded</category>
        
        
        <category>vocore</category>
        
      </item>
    
      <item>
        <title>入手VoCore</title>
        <description>&lt;p&gt;由于项目需要用到RT5350，一个廉价的WiFi片上芯片，在网上搜索相关资料之后，找到了VoCore这个国内的开源项目，一个带用WiFi的硬币大小的Linux计算机。如果感兴趣的话可以了解一下&lt;a href=&quot;http://vonger.cn/&quot;&gt;作者的博客&lt;/a&gt;和&lt;a href=&quot;https://www.indiegogo.com/projects/vocore-a-coin-sized-linux-computer-with-wifi&quot;&gt;相关介绍&lt;/a&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;blockquote&gt;
  &lt;h1 id=&quot;vocore&quot;&gt;什么是VoCore？&lt;/h1&gt;
  &lt;p&gt;VoCore是运行OpenWrt的开源硬件。尽管WIFI, USB, UART, 20+ GPIO一应俱全，但是大小为1英寸（25mm x 25mm）。它提供了很多的接口，比如说10/100M以太网口、USB、UART、I2C、I2S、PCM、JTAG和超过20个的GPIO口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正如你所看到的，VoCore非常地小，接口也非常密，这个版本没有提代外接的天线，直接用贴片的天线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWyLSbrI/medium.jpg&quot; alt=&quot;VoCore正面&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWyMgd04/medium.jpg&quot; alt=&quot;VoCore背面&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以下是它的接口/引脚图，接口非常的丰富，使用必须用电烙铁焊上去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWDDYtLs/medish.jpg&quot; alt=&quot;VoCore引脚图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作者除了本身的博客之外，不提供其它的资料，所示还是先看看他的博客吧。&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Jul 2014 00:00:00 +0800</pubDate>
        <link>/vocore/2014/07/30/get_vocore</link>
        <guid isPermaLink="true">/vocore/2014/07/30/get_vocore</guid>
        
        <category>vocore</category>
        
        <category>embedded</category>
        
        
        <category>vocore</category>
        
      </item>
    
      <item>
        <title>在Jekyll上使用分页</title>
        <description>&lt;p&gt;一个博客不可能只有几篇文章，如果所有文章全部放在一个页面中，在文章不多的情况下也许较为直观，一旦文章数量增加，不仅加大了用户需要加载的数据量，也为用户检索文章造成了障碍，所以基本上每个博客都会有文章的分页。一般的分页都是通过像JSP的模板引擎直接在从数据库中分页取出时生成动态生成页面，或者通过ajax从数据库分页取出传递到前端。但现在github+jekyll是静态的页面，没有数据库。好在jekyll支持分页功能。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;section&quot;&gt;开启分页功能&lt;/h1&gt;

&lt;p&gt;首先我们需要在jekyll中开启分页功能，在jekyll的_config.yml中加入分页配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paginate: 5
paginate_path: &quot;page:num&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行定义了每页的文章数量，而第二行则定义了在分页的结果，比如在/index.html中使用分页，定义为page:num，则第二页的路径将是/page2/index.html，第三页的路径将是/page3/index.html，以此类推。&lt;/p&gt;

&lt;p&gt;需要注意的几个点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分页只在html文件中起作用&lt;/li&gt;
  &lt;li&gt;paginate_path同时定义了需要被分页的文件，本人测试这个叫index.html，具体目录由paginate_path中的路径定义，如果定义的目录没有，则会向上寻找index.html，直到根目录的index.html，具体机制官网上没有详细说，所以还需要进一步实验&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;使用分页&lt;/h1&gt;

&lt;p&gt;只是开启了分页还没有用，我们需要确实使用到首页之中，在首页(/index.html)中添加如下代码：&lt;/p&gt;

&lt;p&gt;这样，jekyll就会根据paginator来进行分页了，被分出来多少页，就会有多少个页面生成。排1-5的文章就在/index.html中了，而排6-10的文章则在/page2/index.html中，依次类推。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;换页&lt;/h1&gt;

&lt;p&gt;只是分页还不够，我们还需要在每个页面上做一个跳转到其他页面的导航，这里需要用到paginator的一些其他属性。&lt;/p&gt;

&lt;p&gt;首先检测总的页数，如果只有一页，自然就不需要分页了。通过paginator的total_pages属性能判断总页数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if paginator.total_pages &amp;gt; 1 %}
&amp;lt;!-- 分页代码 --&amp;gt;
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要一个跳转到上一页的按钮，这个按钮在第一页不需要显示，通过paginator的previous_page属性来判断是否是第一个页面，使用paginator的previous_page_path来输出上一页的路径，注意在前面添加baseurl，并进行一些必要的字符替换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if paginator.previous_page %}
    &amp;lt;a href=&quot;{{ paginator.previous_page_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;上一页&amp;lt;/a&amp;gt;
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着是生成所有页面的按钮，并使当前页按钮无效化，遍历所有页面，使用paginator的page属性来确定当前页，如果是当前页，则按钮无效，否则使用&lt;code&gt;{{ site.paginate_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; | replace: &#39;:num&#39;, page }}&lt;/code&gt;来将&lt;code&gt;:num&lt;/code&gt;替换成当前页面的数字生成页面路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for page in (1..paginator.total_pages) %}
    {% if page == paginator.page %}
      &amp;lt;span class=&quot;active&quot;&amp;gt;{{ page }}&amp;lt;/span&amp;gt;
    {% elsif page == 1 %}
      &amp;lt;a href=&quot;{{ &#39;/index.html&#39; | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&amp;gt;{{ page }}&amp;lt;/a&amp;gt;
    {% else %}
      &amp;lt;a href=&quot;{{ site.paginate_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; | replace: &#39;:num&#39;, page }}&quot;&amp;gt;{{ page }}&amp;lt;/a&amp;gt;
    {% endif %}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后生成一个下一页的按钮，在最后一页不显示，和上一页按钮类似，通过paginator的next_page_path来确定是否还有下一页：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if paginator.next_page %}
    &amp;lt;a href=&quot;{{ paginator.next_page_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&amp;gt;下一页&amp;lt;/a&amp;gt;
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个完整的分页导航功能就做好了，效果就和博客主页上的分页效果是一样的。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;jekyll的分页总的来说还算给力，基本的功能可以完成。但是有一些缺陷，就是category，tag的分类分页无法实现，必须通过插件的方式来做。但是github不允许三方插件，所以只能通过一些其他的方式实现了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文转自：&lt;a href=&quot;http://blog.segmentfault.com/skyinlayer/1190000000406015&quot;&gt;http://blog.segmentfault.com/skyinlayer/1190000000406015&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Jul 2014 00:00:00 +0800</pubDate>
        <link>/daily/2014/07/26/pagination_on_jekyll</link>
        <guid isPermaLink="true">/daily/2014/07/26/pagination_on_jekyll</guid>
        
        <category>jekyll</category>
        
        
        <category>daily</category>
        
      </item>
    
  </channel>
</rss>
